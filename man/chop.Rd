% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/chop.R
\name{chop}
\alias{chop}
\alias{unchop}
\title{Chop and unchop}
\usage{
chop(df, cols)

unchop(df, col, id = NULL, keep_empty = FALSE, ptype = NULL)
}
\arguments{
\item{df}{A data frame.}

\item{col, cols}{Column to unchop (automatically quoted).

This should be a list-column containing generalised vectors (e.g.
any mix of \code{NULL}s, atomic vector, S3 vectors, a lists, or data frames).}

\item{id}{A string specifying giving the name of a new column which will
contain the inner names of \code{col}. If unnamed, \code{col} will instead contain
numeric indices.}

\item{keep_empty}{By default, elements of \code{col} that have size zero will
be ommitted from the output. Setting \code{keep_empty = TRUE} will ensure
that they're preserved}

\item{ptype}{Optionally, supply a prototype for the output \code{col}, overriding
the default that will be guessed from the combination of individual
values.}
}
\description{
Chopping and unchopping preserve the width of a data frame, changing its
length. \code{chop()} makes \code{df} shorter by converting rows within each group
into list-columns. \code{unchop()} makes \code{df} longer by expanding list-columns
so that each element of the list-column gets its own row in the output.
}
\details{
Generally, unchopping is more useful than chopping because it simplifies
a complex data structure, and \code{\link[=nest]{nest()}}ing is usually more appropriate
that \code{chop()}ing` since it better preserves the connections between
observations.

Learn more in \code{vignette("chop-pack-nest")}.
}
\examples{
# Chop ==============================================================
df <- tibble(x = c(1, 1, 1, 2, 2, 3), y = 1:6, z = 6:1)
# Note that we get one row of output for each unique combination of
# non-chopped variables
df \%>\% chop(c(y, z))
# cf nest
df \%>\% nest(c(y, z))

# Unchop ============================================================
df <- tibble(x = 1:4, y = list(integer(), 1L, 1:2, 1:3))
df \%>\% unchop(y)
df \%>\% unchop(y, keep_empty = FALSE)

# Preserving names --------------------------------------------------
df <- tibble(
  x = 1:3,
  y = list(A = c(a = 1L), B = c(b1 = 1, b2 = 2), C = c(c = 3))
)
df \%>\% unchop(y)
df \%>\% unchop(y, id = "y_name")

# Incompatible types -------------------------------------------------
# If the list-col contains types that can not be natively
df <- tibble(x = 1:2, y = list("1", 1:3))
try(df \%>\% unchop(y))
df \%>\% unchop(y, ptype = integer())
df \%>\% unchop(y, ptype = character())
df \%>\% unchop(y, ptype = list())

# Unchopping data frames -----------------------------------------------------
# Unchopping a list-col of data frames must generate a df-col because
# unchop leaves the column names unchanged
df <- tibble(x = 1:3, y = list(NULL, tibble(x = 1), tibble(y = 1:2)))
df \%>\% unchop(y)
df \%>\% unchop(y, keep_empty = FALSE)
}
